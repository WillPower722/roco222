# **Lab Journal: Will Redhead**
                 (Partnered with Peter Allen)

# **Markdown**

## **What it's about**

Markdown is a simplified way of formatiing text for browsers

### **Rules**

* Paragraphs are seperated by a blank line
* Two spaces at end of line create a line break
* Images defined by ![Image Name](/images/filename.png)
* Links defined by [Link NAME](HTTP://LINK.COM)
* Code blocks fenced by:
'''javascript
function example(){
   code
}
'''
* \*actual asterisk format\*
* - [x] is a complete item
* - [ ] is an incomplete item

---

# **Command line**

$ ls displays list of folders on OS  
$ cd /tmp changes the '-' in front of the '$' to '/tmp'  
$ cd $HOME changes back to '-'  
$ mkdlr opens the directory for the terminalusing a keyword (eg mkdlr --help)  
$ echo "Hello" > hello.md writes "Hello" to hello.md file  
$ cat hello.md calls "Hello" on the next line  
$ cp hello.md hello-again.md copies hello.md to hello-again.md  
$ mv hello-again.md hello-hello.md moves hello-again.md file to hello-hello.md  
$ rm hello.md removes the file  
$ rm -rf removes all files (with permission) and all recursive files  
$ cat /proc/cpuinfo displays all info on the CPU  

---

# **DC motor build**

### **Components**

* Commutator: The commutator is the two adhesive copper strips attatched to the cork which, when voltage is applied, will periodically flip the current direction allowing the motor to rotate.
* Brush: the brush is a peice of metal that is not attached to the motor directly, but while the motor rotates the brush will remain stationary and make contact with the two peices of copper tape (Commutator) which will cause the flow of current to flip.
* Magnets: the powerful magnets pull on the magnetic feild generated by the wires which, because the magnetic feilds flip, allows the commutator to rotate.
Copper wire: We used 75 turns of copper wire for the coil.

### **Improvements**

* Comutator: We changed the commutator to have 4 strips of copper tape and 2 coils of copper wire with 60 turns each to improve the electro-magnetic field and to allow the magnets to have a greater affect on the motor. We also added an extra block of cork to the body to create more support for the copper strips.
* Brush: we swapped the wire we were using from a single length of metal to a wire with multiple frayed wires for more consistent contact with the copper strips.

![motor spin](https://user-images.githubusercontent.com/32261837/34827503-50ac6e1e-f6d2-11e7-92aa-b8c155204f56.gif)

---

# **Incremental encoder**

### **Build**

For the incremental encoder we built a disc out of thick paper, cut a quarter out of it and attached it to our motor with blue tac. Next we built the encoder using an infared transmitter and an infared receiver and put it either side of the disc.
We then used the arduino board to connect to the encoder and pogrammed the board so that every time the infared receiver measures a rising pulse, we increment a variable by 1.

### **Code**

This wasn't my first time using arduino so I managed to get the code working using the example code by adding 2 voids and a loop. 

**#define NOT_AN_INTERRUPT -1

**const byte ledPin = 13;
const byte interruptPin = 2;
volatile byte state = LOW;
int pulseCounter = 0;

**void setup() {
  pinMode(ledPin, OUTPUT);
  pinMode(interruptPin, INPUT);
  Serial.begin(9600); // set up Serial library at 9600 bps

  **// configure the interrupt call-back: blink is called everytime the pin
  // goes from low to high.
  attachInterrupt(digitalPinToInterrupt(interruptPin), blink, RISING);
**}

**void loop() {
  digitalWrite(ledPin, state);
  String counterString = String(pulseCounter);
  Serial.println(counterString); // prints hello with ending line break
  delay(1000); // wait 1s
**}

**void blink() {
  state = !state;
  pulseCounter++;
}**

![Encoder](https://user-images.githubusercontent.com/32261837/34827621-a92cca02-f6d2-11e7-8f32-7fc99b39b35c.jpg)

### **Testing**

We ran the the motor after uploading the code to the board and ran the program for 20 seconds and multipied the result by 3; we did this 3 times to get an avrage of about 10,000 rpm which seems to be too high so we will need to calibrate our design to aquire a more reasonable value.

---

# **Stepper Motor**

### **One phase**

A one-phase motor has 4 poles and a magnet in the middle. The poles work so that only one pole is magnetically activie at a time and switch to an adjacent magnet to draw the magnet in the middle round in a circle.

Here is the code we used:

**void setup(){
 
 **//set up channels A and B
 pinMode(12, OUTPUT);  //Initiates Motor Channel A pin
 pinMode(9, OUTPUT);   //Initiates Brake Channel A pin
 pinMode(13, OUTPUT);  //Initiates Motor Channel B pin
 pinMode(8, OUTPUT);   //Initiates Brake Channel B pin
}

**void loop(){
  
  **digitalWrite(12, HIGH); //Establishes forward direction of Channel A
  digitalWrite(9, LOW);   //Disengage the Brake for Channel A
  analogWrite(3, 255);    //Spins the motor on Channel A at full speed
  digitalWrite(13, HIGH); //Establishes forward direction of Channel B
  digitalWrite(8, LOW);   //Disengage the Brake for Channel B
  analogWrite(11, 0);    //Spins the motor on Channel B at full speed
  
  **delay(1);
  
  **analogWrite(3, 0);    //Spins the motor on Channel A at full speed
  analogWrite(11, 255);    //Spins the motor on Channel B at full speed

  **delay(1);
  
  **digitalWrite(12, LOW); //Establishes backward direction of Channel A
  analogWrite(3, 255);    //Spins the motor on Channel A at full speed
  digitalWrite(13, LOW); //Establishes backward direction of Channel B
  analogWrite(11, 0);    //Spins the motor on Channel B at full speed
  
  **delay(1);
  
  **analogWrite(3, 0);    //Spins the motor on Channel A at full speed
  analogWrite(11, 255);    //Spins the motor on Channel B at full speed

  **delay(1);

**}**

### **Two Phase**

A two phase motor is designed similarly to theone phase except that two of the magnets are active at the same time. Instead of just one pole drawing the magnet round in a circle, the pole opposite the active one also becomes active but with a different polarity so that the magnet rotates faster. Although more energy is used, the rotation is quicker.

Here is the code we used for Two Phase:

**void setup(){
 
 **//set up channels A and B
 pinMode(12, OUTPUT);  //Initiates Motor Channel A pin
 pinMode(9, OUTPUT);   //Initiates Brake Channel A pin
 pinMode(13, OUTPUT);  //Initiates Motor Channel B pin
 pinMode(8, OUTPUT);   //Initiates Brake Channel B pin
}

**void loop(){
  
  **digitalWrite(12, HIGH); //Establishes forward direction of Channel A
  digitalWrite(9, LOW);   //Disengage the Brake for Channel A
  analogWrite(3, 255);    //Spins the motor on Channel A at full speed
  digitalWrite(13, HIGH); //Establishes forward direction of Channel B
  digitalWrite(8, LOW);   //Disengage the Brake for Channel B
  analogWrite(11, 255);    //Spins the motor on Channel B at full speed
  
  **delay(1);
  
  **digitalWrite(12, LOW); //Establishes backward direction of Channel A

  **delay(1);
  
  **digitalWrite(13, LOW); //Establishes backward direction of Channel B
  
  **delay(1);
  
  **digitalWrite(12, HIGH); //Establishes forward direction of Channel A

  **delay(1);

**}**

---

# **Robot Arm Project**

## **Servo motor control**

Using the example Arduino code we managed to quickly work out how to control the servo motor after some trial and error with delay times. Here is the code we came up with:

**void setup(){**
  
  **pinMode(9, OUTPUT);**
  **Serial.begin(9600);**
}

**void loop(){**
 
 **int potValue = analogRead(A0); //reads the potentiometer value**
 
 **int timing = 400 + (potValue * 2); //this value can range from the smallest delay the motor can read, to the largest**

 **digitalWrite(9, HIGH);**
 
 **delayMicroseconds(timing);**
 
 **digitalWrite(9, LOW);**

 **delay(10);**
}

This code only controls one motor and we will be using 2 in the project.

## **Arm Design**

For the arm we will only have 2 axis of movement so we are going to make an arm that moves back and forth and grab things with a claw. We are going for a small arm design to keep it lightweight and efficient; the 3D print material shoud be strong enough so that the arm doesnt bend or break. We intend to have the first motor attached to a base which will be connected to two arms to form the top of a triangle and when the arm changes angle a horizontal rail arm will slide back and forth making the base of the arm triangle longer. At the end of the rail arm we will put a slot for the motor and a static platform which will act as one of the claws. The other claw will be controlled by the motor and will open and close like a mouth.

## **Build**

We successfully printed all the componets for the arm (although we had to re-print the rail arm due to a measurement error). When we came to putting the pieces together we realised that some components didn't fit perfectly together (most likely due to non-perfect accuracy from the 3D printer) and so, over the Christmas holiday, I managed to file/sand some of these slots so that the parts all fit comfortably together. We also glued washers to end of the pegs holding the arm together to ensure it doesnt fall apart while it's in use.

This is the arduino code we used to control the two motors:

**void setup(){
  
  **pinMode(9, OUTPUT);
  **pinMode(10, OUTPUT);
  **Serial.begin(9600);
**}

**void loop(){
 
 **int potValue1 = analogRead(A0);
 int potValue2 = analogRead(A1);
 int timing1 = 400 + (potValue1);
 int timing2 = 400 + (potValue2);

 **digitalWrite(9, HIGH);
 
 **delayMicroseconds(timing1);
 
 **digitalWrite(9, LOW);
 
 **delay(10);
 
 **digitalWrite(10, HIGH);
 
 **delayMicroseconds(timing2);
 
 **digitalWrite(10, LOW);

 **delay(10);
}**

## **Final arm build**

![dsc_0457](https://user-images.githubusercontent.com/32261837/34829529-e960a37c-f6d8-11e7-9717-a96f6f1ff0ca.JPG)

### **Issues:**

* The claw doesn't perfectly align with its counterpart; this could be due to error in measurements and also the way all the pats fit together not being as millimeter accurate as our CAD design was.
* The pegs and holes that bind the arms together create a lot of friction so we had to file those down to allow the joints to rotate with ease.
* The pegs which were attached to the base which wer built to screw the motor onto were a little too small and fragile so they snapped off. We decided to glue the servo to the base as a backup solution.
* The last issue is that that, because the arm is quite small, ith is fairly flexible and not massively heavy so if it were to try and pull something heavier than itself, it would pull itself towards said object.

### **Advantages**

* Due to its size, the arm is very portable and can fit in a small bag if needed without needing to be taken apart and reassembled.
* Because of the way we designed it, the arm had a very long reach and can extend almost the whole length of the rail arm.
* Since we chose to stick with 2 servo motors, the arm is quite easy to control using arduino code.

